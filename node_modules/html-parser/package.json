{
  "name": "html-parser",
  "version": "0.7.0",
  "description": "HTML/XML parser with less explosions",
  "keywords": [
    "html",
    "xml",
    "parser",
    "explosion"
  ],
  "author": {
    "name": "Tommy Montgomery",
    "email": "tmont@tmont.com",
    "url": "http://tmont.com/"
  },
  "license": "MIT",
  "contributors": [
    {
      "name": "jdponomarev"
    }
  ],
  "main": "./src/parser.js",
  "directories": {
    "lib": "./src"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tmont/html-parser.git"
  },
  "devDependencies": {
    "mocha": "1.8.1",
    "should": "1.2.1"
  },
  "scripts": {
    "test": "node_modules/.bin/mocha -R spec ./tests"
  },
  "readme": "# html-parser\n\n[![Build Status](https://travis-ci.org/tmont/html-parser.png)](https://travis-ci.org/tmont/html-parser)\n\nNow with less explosions!\n\nThe purpose of this library is not to be the best XML parsing library ever\nconceived. Because it's not. It's meant to be an HTML/XML parser that doesn't\nrequire valid HTML/XML. It's also meant to act as a sanitizer, which is the\nmain reason for it's existence.\n\nFor example, you can just shove a blob of text into it, and it will happily\nparse as if it were valid XML.\n\nLicensed under [MIT](./LICENSE).\n\n## Installation\n`npm install html-parser`\n\n## Callback based parsing\n```javascript\nvar htmlParser = require('html-parser');\n\nvar html = '<!doctype html><html><body onload=\"alert(\\'hello\\');\">Hello<br />world</body></html>';\nhtmlParser.parse(html, {\n\topenElement: function(name) { console.log('open: %s', name); },\n\tcloseOpenedElement: function(name, token) { console.log('close token: %s', token); },\n\tcloseElement: function(name) { console.log('close: %s', name); },\n\tcomment: function(value) { console.log('comment: %s', value); },\n\tcdata: function(value) { console.log('cdata: %s', value); },\n\tattribute: function(name, value) { console.log('attribute: %s=%s', name, value); },\n\tdocType: function(value) { console.log('doctype: %s', value); },\n\ttext: function(value) { console.log('text: %s', value); }\n});\n\n/*\ndoctype: html\nopen: html\nclose token: >\nopen: body\nattribute: onload=alert('hello');\nclose token: >\ntext: Hello\nopen: br\nclose token: />\ntext: world\nclose: body\nclose: html\n*/\n```\n\n## Sanitization\n```javascript\nvar htmlParser = require('html-parser');\n\nvar html = '<script>alert(\\'danger!\\')</script><p onclick=\"alert(\\'danger!\\')\">blah blah<!-- useless comment --></p>';\nvar sanitized = htmlParser.sanitize(html, {\n\telements: [ 'script' ],\n\tattributes: [ 'onclick' ],\n\tcomments: true\n});\n\nconsole.log(sanitized);\n//<p>blah blah</p>\n```\n\n### Using callbacks\n```javascript\nvar htmlParser = require('html-parser');\n\nvar html = '<script>alert(\\'danger!\\')</script><p onclick=\"alert(\\'danger!\\')\">blah blah<!-- useless comment --></p>';\nvar sanitized = htmlParser.sanitize(html, {\n\telements: function(name) {\n\t\treturn name === 'script';\n\t},\n\tattributes: function(name, value) {\n\t\treturn /^on/i.test(name) || /^javascript:/i.test(value);\n\t}\n\tcomments: true\n});\n\nconsole.log(sanitized);\n//<p>blah blah</p>\n```\n\n## API\n```javascript\n/**\n * Parses the given string o' HTML, executing each callback when it\n * encounters a token.\n *\n * @param {String} htmlString A string o' HTML\n * @param {Object} [callbacks] Callbacks for each token\n * @param {Function} [callbacks.attribute] Takes the name of the attribute and its value\n * @param {Function} [callbacks.openElement] Takes the tag name of the element\n * @param {Function} [callbacks.closeOpenedElement] Takes the tag name of the element and the token used to\n * close it (\">\", \"/>\", \"?>\")\n * @param {Function} [callbacks.closeElement] Takes the name of the element\n * @param {Function} [callbacks.comment] Takes the content of the comment\n * @param {Function} [callbacks.docType] Takes the content of the document type declaration\n * @param {Function} [callbacks.cdata] Takes the content of the CDATA\n * @param {Function} [callbacks.xmlProlog] Takes no arguments\n * @param {Function} [callbacks.text] Takes the value of the text node\n */\nparse(htmlString, callbacks)\n\n/**\n * Parses the HTML contained in the given file asynchronously.\n *\n * Note that this is merely a convenience function, it will still read the entire\n * contents of the file into memory.\n *\n * @param {String} fileName Name of the file to parse\n * @param {String} [encoding] Optional encoding to read the file in, defaults to utf8\n * @param {Object} [callbacks] Callbacks to pass to parse()\n * @param {Function} [callback]\n */\nparseFile(fileName, encoding, callbacks, callback)\n\n/**\n * Sanitizes an HTML string.\n *\n * If removalCallbacks is not given, it will simply reformat the HTML\n * (i.e. converting all tags to lowercase, etc.). Note that this function\n * assumes that the HTML is decently formatted and kind of valid. It\n * may exhibit undefined or unexpected behavior if your HTML is trash.\n *\n * @param {String} htmlString A string o' HTML\n * @param {Object} [removalCallbacks] Callbacks for each token type\n * @param {Function|Array} [removalCallbacks.attributes] Callback or array of specific attributes to strip\n * @param {Function|Array} [removalCallbacks.elements] Callback or array of specific elements to strip\n * @param {Function|Boolean} [removalCallbacks.comments] Callback or boolean indicating to strip comments\n * @param {Function|Boolean} [removalCallbacks.docTypes] Callback or boolean indicating to strip doc type declarations\n * @return {String} The sanitized HTML\n */\nsanitize(htmlString, removalCallbacks)\n```\n\n## Development\n```shell\ngit clone https://github.com/tmont/html-parser.git\ncd html-parser\nnpm link\nnpm test\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/tmont/html-parser/issues"
  },
  "_id": "html-parser@0.7.0",
  "dist": {
    "shasum": "18c03b72547d3f2aebdd481ee7d5c50c8fceebe9"
  },
  "_from": "html-parser@",
  "_resolved": "https://registry.npmjs.org/html-parser/-/html-parser-0.7.0.tgz"
}
